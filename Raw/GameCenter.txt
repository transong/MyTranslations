<a href="http://www.raywenderlich.com/wp-content/uploads/2012/10/iOS6_feast_GameKitChallenges.png"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/iOS6_feast_GameKitChallenges.png" alt="Learn about the new Challenges feature in GameKit in iOS 6!" title="Learn about the new Challenges feature in GameKit in iOS 6!" width="250" height="250" class="alignright size-full wp-image-23338" /></a>

<em>Note from Ray:</em> This is the seventh iOS 6 tutorial in the <a href="">iOS 6 Feast</a>! This tutorial is an abbreviated version of one of the chapters from our new book <a href="/?page_id=19968">iOS 6 By Tutorials</a>. Ali Hafizji wrote this chapter - the same guy who's written several Android tutorials for this site in the past. Enjoy!
<em>来自Ray:</em> 这是<a href="">iOS 6 盛宴</a>的第7部分！本篇教程是我们的最新教程大作<a href="/?page_id=19968">iOS 6 By Tutorials</a>的中相应篇章的简略版。Ali Hafizji是本篇教程的作者，他以前在本网站还发表过几篇Android的教程。Enjoy!

<i>This is a blog post by iOS Tutorial Team member <a href="/?page_id=9#alihafizji">Ali Hafizji</a>, an iOS and Android developer working at <a href="http://tavisca.com/">Tavisca Solutions</a>.</i>
<i>本篇教程由iOS教程组成员<a href="/?page_id=9#alihafizji">Ali Hafizji</a>发表，他是一名iOS和Android开发者，目前在<a href="http://tavisca.com/">Tavisca Solutions</a>工作。</i>

You’ve probably heard of Game Center, the online multiplayer social gaming network introduced in iOS 4.1. It allows users to invite friends to play a game, start a multiplayer gaming session, track game achievements, and a lot more.
你也许曾听说过Game Center，它是自打iOS 4.1被引入的在线多人社交游戏网络，支持玩家邀请好友一起玩儿游戏，还可以建立一个多人游戏的会话，追踪成就系统，以及其他功能。

In addition to making implementing these standard social features much easier for developers, it also helps with a fundamental problem: app discovery. With over 1 million apps in the App Store today, the odds of a single user discovering your app can be frustratingly low. Game Center helps to solve this problem by allowing the user to see what games his/her friends are playing, thereby increasing the visibility of your game.
除了可以让开发者更轻松的实现一些基本功能外，它还改善了另一个基础问题：app推广。如今App Store上有超过1百万款app，单个用户发现你的app的概率将会非常低。Game Center通过好友系统改善了此类问题，你可以查看你的好友都在玩儿些什么游戏，因此你的游戏的曝光率被增加了。
 
iOS 6.0 introduces new APIs in Game Center that not only continue to help your game gain visibility, but also increase user engagement. One such feature is the ability to send game challenges to friends, even those who don’t have the game installed. For example, a user could get a high score in your game and send a challenge to their friend saying “Hah, beat this!”
iOS 6.0为Game Center引入了一系列新的API，它们不仅可以增加你的游戏曝光率，而且还能增加用户粘性。其中一项功能是挑战好友，即使你的Gamecenter好友们没有安装此游戏，也可以邀请向他们发送挑战。例如，一个玩家在你的游戏里得到了高分，他可以向他的朋友发送一个挑战邀请并且说：“嘿，来试试赢我啊！”

When the friend receives the challenge, they will see the message along with a direct link to download your app. It’s not hard to imagine how this could increase user retention manyfold! When you consider the large number of players using Game Center, this alone is a very good reason to add challenges to your games.
当朋友接收到挑战后，会立即看到消息中你的游戏的链接。不难想象这一特性能够成倍的增加用户留存率！由于考虑到Game Center上庞大的用户群体，这一点足够说明你应该在游戏中添加挑战功能。

Before you can use challenges you need to use Game Center, so first this tutorial will take you through setting up Game Center and setting up a simple leaderboard, highlighting all the iOS 6 updates along the way.
使用挑战之前要先使用Game Center，所以本篇教程将首先带你整体过一遍Game Center，包括设置Game Center并添加一个简单的排行榜，同时会在过程中指出iOS 6新增的内容。

<em>Note:</em> This tutorial assumes that you have prior knowledge of Cocos2D and have built games using it. If you are new to Cocos2D, you can read some of the many <a href="/?page_id=2519#cocos2d">Cocos2D tutorials</a> available on this website.<!--more--><h2>The MonkeyJump game</h2>
<em>注意:</em> 本篇教程要求你熟悉Cocos2D并且基于它制作过游戏。如果你是Cocos2D的新手，可以先在本网站学习<a href="/?page_id=2519#cocos2d">Cocos2D系列教程</a>。<!--more--><h2>跳跃猴游戏</h2>

First <a href="http://www.raywenderlich.com/downloads/MonkeyJumpStarter.zip">download the starter project</a> for this tutorial - MonkeyJump!
首先下载<a href="http://www.raywenderlich.com/downloads/MonkeyJumpStarter.zip">初始工程</a> - 跳跃猴！

MonkeyJump is a simple side scroller written using my favorite game engine, Cocos2D. It was originally based on a simple game called CatJump developed for a Learning Cocos2D workshop, but I added some new features to make it more fun and added some cute new art from <a href="http://www.vickiwenderlich.com">Vicki Wenderlich</a>.
MonkeyJump（跳跃猴）是一个简单的横向卷轴游戏，它由我最喜欢的游戏引擎Cocos2D制作的。它是基于一个由Cocos2D学习工作室制作的叫做CatJump的游戏。我向其中加了一些有趣的元素，另外<a href="http://www.vickiwenderlich.com">Vicki Wenderlich</a>为游戏制作了新的美术资源。

The main character of the game is, obviously, a monkey :] The objective of the game is to make the monkey cover the maximum possible distance while avoiding as many enemies as he can. 
游戏中的主要角色很明显，是一只猴子，游戏的主要目标让猴子达到最远的距离同时躲避敌人。

MonkeyJump is easy to play – even your mom could play! The player simply has to tap the screen to make the monkey jump over enemies. The game keeps track of the distance the monkey runs and uses it to determine the player’s score.
MonkeyJump非常容易上手，即使是你的妈妈也能玩儿！只需要轻点屏幕就可以让猴子跳过敌人了。游戏会记录猴子跑的距离并以此为玩家打分。

<a href="http://www.raywenderlich.com/?attachment_id=23246" rel="attachment wp-att-23246"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/game_layout.png" alt="" title="game_layout" width="637" height="414" class="alignnone size-full wp-image-23246" /></a>

Try it out for yourself! Unzip the starter project, open it in Xcode and build and run. Try to see how far you can get! :]
亲自是玩儿一下吧！把starter项目解压，在Xcode中编译并运行。试试看你能跑多远！:]

Also go through the source code to understand how the layers and scenes work together.
另外简单过一遍代码，看看这些层和场景之间是如何协调工作的。

<h2>配置Game Center</h2>

As mentioned earlier, before you to do anything with Game Center Challenges, you first have to set up your app to use Game Center! And to do that, you need to do three things:
在做任何有关Game Center Challenges功能之前，首先要做的就是配置你的app使用Game Center！这个过程需要三个步骤：

<ol>
<li>Create and set an App ID.</li>
<li>创建并设置App ID。</li>
<li>Register your app on iTunes Connect.</li>
<li>在iTunes Coonect上注册你的app。</li>
<li>Enable Game Center features such as leaderboards.</li>
<li>启用Game Center的功能，比如leaderboards（排行榜）</li>
</ol>

Let’s go through each of these steps in turn. This will be old hat for many readers, but I promise we’ll go through these necessary tasks quickly.
让我们按顺序过一遍这些步骤。对于许多有Game Center经验的读者来说，这会是相当熟悉的，但我保证我会很快的讲完这一部分。

<h3>Creating and setting an App ID</h3>
<h3>创建并设置App ID</h3>

The first thing you need to do is create an App ID. To do this, log on to the iOS Dev Center and from there, select the iOS Provisioning Portal.
第一步，你需要创建一个App ID。登录到iOS Dev Center，选择iOS Provisioning Portal。

From the Provisioning Portal, select App IDs and create a new App ID. Use monkeyjump as the name and enter a bundle identifier – usually it’s good to use reverse DNS notation for a domain you control like com.ali.MonkeyJump (you can use your name if you don’t have a domain name). 
在Provisioning Portal中，选择App IDs，选择create a new App ID。使用monkeyjump作为游戏名字并输入一个bundle identifier，通常这里使用倒转的DNS命名，比如com.ali.MonkeyJump（如果你没有自己的域名，你可以使用你自己的名字代替）。

<a href="http://www.raywenderlich.com/?attachment_id=23235" rel="attachment wp-att-23235"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/appid-480x270.png" alt="" title="appid" width="480" height="270" class="alignnone size-medium wp-image-23235" /></a>

Once you are done, click the Submit button. Open the MonkeyJump Xcode project, select project root, then the MonkeyJump target (if it’s not selected), and in the Summary tab change the Bundle Identifier to the identifier you created in the iOS Provisioning Portal.
当你完成后，点击Submit按钮。打开MonkeyJump Xcode工程，选择project root，然后选择MonkeyJump target，在Summary tab中把Bundle Identifier替换为你刚刚在Provisioning Portal中创建的那个。

<a href="http://www.raywenderlich.com/?attachment_id=23250" rel="attachment wp-att-23250"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/set_bundle_identifier-480x154.png" alt="" title="set_bundle_identifier" width="480" height="154" class="alignnone size-medium wp-image-23250" /></a>

Give the app a quick compile and run it on a device. If everything is in place the game will start right up. If it doesn’t, clean and build the project and try again.
编译并运行，在真机上运行试试看。如果一切配置都正确的话，游戏应该立刻启动。如果没有，那么clean一下项目并重新编译一次。

<h3>Registering your app in iTunes Connect</h3>
<h3>在iTunes Connect中注册你的app</h3>

The next step is to create a new app on iTunes Connect. Log in to iTunes Connect, switch to the application management screen, and click the Add New App button in the top left corner. (If you have both Mac and iOS developer accounts, you might have to select the type of app – which is iOS, of course)
接下来的步骤是iTunes Connect中创建一个新app。首先登录到iTunes Connect，切换到application management子页面，点击位于左上角的Add New App按钮。（如果你同时拥有Mac和iOS的开发者帐号，你可能需要选择app的类型 - 当然要选择iOS）。

On the first screen, enter MonkeyJump as the game name, 400 as the SKU number (this can be any number/word, so if you want you can set it to something else) and select the Bundle Identifier you created in the previous step.
在第一个屏幕中，输入MonkeyJump作为游戏名字，400作为SKU number（SKU number可以是任意的数字/单词，你也可以设置成你想要的）并选择上一步中创建的Bundle Identifier。

<a href="http://www.raywenderlich.com/?attachment_id=23234" rel="attachment wp-att-23234"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/app_information-480x205.png" alt="" title="app_information" width="480" height="205" class="alignnone size-medium wp-image-23234" /></a>

When you are done entering all the values, press Continue. Follow the prompts and enter all the required details. Since you just need to get through these steps for the purposes of this chapter, fill in only the necessary values and be as brief as you want to be. ☺
当你输入完所有值后，点击Continue。在弹出的提示框中输入所有需要的信息。因为你只需要在本教程中使用此项目，所以一切从简，只填入强制要求填入的项目。☺

You will need to upload a large app icon and a screenshot. To make the process easier, I have uploaded an <a href="http://www.raywenderlich.com/downloads/MonkeyJumpiTunes.zip">iTunes resources file</a> for you.  You can extract the ZIP file and upload these to quickly finish the registration process.
你需要上传一个大的app icon 和一个截图。为了让过程更容易，我为你准备好了<a href="http://www.raywenderlich.com/downloads/MonkeyJumpiTunes.zip">iTunes resources file</a>。你可以解压这个ZIP文件，使用里边的图片来很快的完成这个烦人的注册过程。

When you’re done, click on the Save button and if everything went fine, you will be presented with the following screen: 
当你完成后，点击Save按钮，如果一切都OK的话，你会得到以下提示：

<a href="http://www.raywenderlich.com/?attachment_id=23233" rel="attachment wp-att-23233"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/app_info_entered-700x427.png" alt="" title="app_info_entered" width="700" height="427" class="alignnone size-large wp-image-23233" /></a>

Hurray! You have registered your app with iTunes Connect and completed the most perfunctory business. Now there are just a few more steps to activate Game Center. Don’t worry, the tough part is over. ☺
欢呼！你已经在iTunes Connect中注册了你的app并完成了最敷衍了事的部分，哈哈。接下来还需要几个小步骤来激活Game Center。不要慌张，因为最麻烦的部分已经过去了。☺

<h3>Enabling Game Center features</h3>
<h3>启用Game Center的功能</h3>

Click the blue Manage Game Center button and then click the Enable for Single Game button. Awesome! You have just enabled Game Center for your game. Yep, it is as simple as clicking a button – but you still have a bunch of code to write. :]
点击蓝色的Manage Game Center按钮并点击Enable for Single Game Button。太棒了！你已经为你的游戏启用了Game Center了。这个步骤简单到只需要点击按钮 - 不过别高兴的太早，之后你还是需要写很多的代码才行哦。:]

<a href="http://www.raywenderlich.com/?attachment_id=23239" rel="attachment wp-att-23239"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/enable_game_center-567x500.png" alt="" title="enable_game_center" width="567" height="500" class="alignnone size-large wp-image-23239" /></a>

You aren’t done with this section yet – you still need to add a leaderboard. You might wonder why you have to bother with leaderboards since this chapter is about challenges – don’t worry, you will see why later!
你还没有完成本部分，还要添加一个leaderboard（排行榜）才算完。你可能会问这篇教程不是讲challenges的吗，跟leaderboard有什么关系呢，别急，稍后你就明白了！

For now, take my word at it and add a leaderboard and some challenges, starting with a leaderboard. Click the Add Leaderboard button and select the Single Leaderboard type. You will be presented with a form, like so: 
使用challenge要求添加一个leaderboard。点击Add Leaderboard按钮并选择Single Leaderboard类型。之后你会看到一个如下的表格：

<a href="http://www.raywenderlich.com/?attachment_id=23237" rel="attachment wp-att-23237"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/create_leaderboard-480x175.png" alt="" title="create_leaderboard" width="480" height="175" class="alignnone size-medium wp-image-23237" /></a>

Enter the leaderboard reference name as High Scores and the leaderboard ID as HighScores.
在leaderboard reference name栏输入High Scores，leaderboard ID栏输入HighScores。

<div class="note"><p><em>Note:</em> I generally recommend you keep the leaderboard/achievement ID as an extension of the package name. For example, in the above case for me it would be com.ali.MonkeyJump.HighScores (you would need to replace the com.ali part to match your own setup). But for the purposes of this tutorial, just name it plain HighScores (without the reverse domain name prefix) to keep things simple.</p></div>
<div class="note"><p><em>注意：</em> 一般来说，我推荐你使用包名字的扩展作为leaderboard或者achievement（成就）的ID。例如，以上的名字就是com.ali.MonkeyJump.HighScores（你需要把com.ali替换为你自己的）。但是为了本篇教学的简化，直接把它命名为HighScores（而不是加上域名的前缀）。</p></div>

Set the Sort Order as High to Low and the Score Format Type as Integer. Finally, click on the Add Language button. Enter the language details as shown below:
把Sort Order设置为High to Low，Score Format Type设置为Integer。最后，点击Add Language按钮。为language details添入以下内容：

<a href="http://www.raywenderlich.com/?attachment_id=23247" rel="attachment wp-att-23247"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/highscores_leaderboard-700x438.png" alt="" title="highscores_leaderboard" width="700" height="438" class="alignnone size-large wp-image-23247" /></a>

Adding an image is not mandatory, but is always a good practice. The one used above is included in the iTunes resources (it’s named icon_leaderboard_512.png), and you can use it here for the high scores leaderboard. When you’re done, click Save. 
此处添加图片不是虽然强制的，但是添加它是个很好的实践机会。这里你需要使用的资源是iTunes resource文件夹中名字为icon_leaderboard_512.png，把它用作高分排行榜的icon。当你完成后，点击Save。

Finally, click on the Done button. For now, one leaderboard is enough, but in the future if you want to add more, you now know the drill. 
最后，点击Done按钮。到这里，一个leaderboard的配置就完成了，以后如果你想添加更多的，你就可以随心所欲了。

<h2>Authenticating the local player</h2>
<h2>验证本地玩家</h2>

Before you start writing code, you need to import the GameKit framework. Open the MonkeyJump project in Xcode 4.5 and navigate to the target settings. Open the Build Phases tab and expand the Link Binary With Libraries section. Click the “+” button and add the GameKit framework to the project.
在你开始写代码之前，你需要首先import（导入）GameKit framework。在 Xcode 4.5 中打开MonkeyJump工程并进入target设置。打开Build Phases子页面，选择Link Binary With Libraries部分。点击 “+” 按钮，选择导入GameKit framework到工程中。

<a href="http://www.raywenderlich.com/?attachment_id=23232" rel="attachment wp-att-23232"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/add_game_kit-280x320.png" alt="" title="add_game_kit" width="280" height="320" class="alignnone size-medium wp-image-23232" /></a>

Next you will write code to authenticate the player. Without authenticating the player, you cannot use any of the awesome features that Game Center provides.
接下来你需要写一些代码来验证用户。注意如果你不验证用户，你是不能够使用任何Game Center提供的很棒的功能的。

Player here means the user who is playing your game. In Game Center terms, this is the <em>GKLocalPlayer</em>.
这里的Player代表当前正在玩儿你的游戏玩家。在Game Center的术语里，这由<em>GKLocalPlayer</em>表示。

Player authentication is a simple two-step process:
验证过程简单的分为两个步骤：
<ol>
<li>First you make an authenticate call to the Game Center platform.</li>
<li>首先你调用一个authenticate call 到 Game Center平台。</li>
<li>The platform then asynchronously calls you back when authentication is complete. If the player was already logged in (95% of the time), a welcome banner is presented. If not, then a login screen is presented which also allows the player to register.</li>
<li>平台会异步的处理你的请求，结束后会调用一个回调函数。如果玩家已经登录了（95%的情况），一个欢迎的横幅会弹出来，如果玩家没登录，那么一个允许玩家注册的登录界面会弹出来。</li>
</ol>

Let’s write some code. You are going to use a singleton pattern, so that all the Game Center code is in one class.
我们这就写些代码。这里我们使用一个单例模式，也就是说所有的Game Center的代码都在一个类中。

Right-click on the MonkeyJump group in Xcode and select New Group. Name the group <em>GameKitFiles</em>. Next, right-click on the newly-created group and select New File…, then select the Objective-C Class template. Name the class <em>GameKitHelper</em> and make sure it extends <em>NSObject</em>.
在Xcode中，右键点击MonkeyJump group，选择New Group。把新group命名为<em>GameKitFiles</em>。然后，右键点击新创建的这个group并选择New File…，文件模版选择Objective-C Class template。把文件命名为<em>GameKitHelper</em>，同时继承<em>NSObject</em>。

<a href="http://www.raywenderlich.com/?attachment_id=23245" rel="attachment wp-att-23245"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/game_kit_helper_class-700x472.png" alt="" title="game_kit_helper_class" width="700" height="472" class="alignnone size-large wp-image-23245" /></a>

Replace the contents of <em>GameKitHelper.h</em> with the following:
把<em>GameKitHelper.h</em>中的内容替换为以下内容：

<pre lang="objc">
//   Include the GameKit framework
#import <GameKit/GameKit.h>

//   Protocol to notify external
//   objects when Game Center events occur or
//   when Game Center async tasks are completed
@protocol GameKitHelperProtocol<NSObject>
@end


@interface GameKitHelper : NSObject

@property (nonatomic, assign)
    id<GameKitHelperProtocol> delegate;

// This property holds the last known error
// that occured while using the Game Center API's
@property (nonatomic, readonly) NSError* lastError;

+ (id) sharedGameKitHelper;

// Player authentication, info
-(void) authenticateLocalPlayer;
@end
</pre>

The code is self-explanatory and is heavily commented. All you are doing here is declaring two methods and two properties – one is the delegate, and the other will hold the last error that occurred while using the GameKit framework.
以上代码自说明性很强并且有很详细的注释。你在此所做的无非就是声明两个方法和两个属性，其中一个属性是delegate，另外一个会记录下最近一次使用GameKit framework报出的错误。

Switch to <em>GameKitHelper.m</em> and replace its contents with the following:
切换到<em>GameKitHelper.m</em>并把文件替换为以下内容：

<pre lang="objc">
#import "GameKitHelper.h"
#import "GameConstants.h"

@interface GameKitHelper ()
        <GKGameCenterControllerDelegate> {
    BOOL _gameCenterFeaturesEnabled;
}
@end

@implementation GameKitHelper

#pragma mark Singleton stuff

+(id) sharedGameKitHelper {
    static GameKitHelper *sharedGameKitHelper;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedGameKitHelper =
                [[GameKitHelper alloc] init];
    });
    return sharedGameKitHelper;
}

#pragma mark Player Authentication

-(void) authenticateLocalPlayer {
    
  GKLocalPlayer* localPlayer =
    [GKLocalPlayer localPlayer];

    localPlayer.authenticateHandler =
    ^(UIViewController *viewController,
      NSError *error) {
        
        [self setLastError:error];
        
        if ([CCDirector sharedDirector].isPaused)
            [[CCDirector sharedDirector] resume];
        
        if (localPlayer.authenticated) {
            _gameCenterFeaturesEnabled = YES;
        } else if(viewController) {
            [[CCDirector sharedDirector] pause];
            [self presentViewController:viewController];
        } else {
            _gameCenterFeaturesEnabled = NO;
        }
    };
}
@end
</pre>

You have declared a variable called <em>_gameCenterFeaturesEnabled</em>. This BOOL variable will be true if authentication was successful, and in any other case will be false.
这里你声明了一个名为<em>_gameCenterFeaturesEnabled</em>的变量。这个BOOL类型的变量会标识验证是否成功。

The way to authenticate a player has changed in iOS 6.0. All you need to do now is set the authenticationHandler of the <em>GKLocalPlayer</em> object, as seen in the -authenticateLocalPlayer method. The authenticationHandler is a block that takes two parameters and is called by the Game Center platform. 
This block is called by the system in a number of scenarios:
iOS 6.0中验证玩家的方式有所改变。所有你需要的就是这是<em>GKLocalPlayer</em>对象的authenticationHandler属性，正如你在authenticateLocalPlayer方法中看到的。authenticationHandler block有两个参数，它是被Game Center平台自动调用的。
这个block被系统在以下情形中被调用：
<ul>
<li>When you set the authenticationHandler and request for the player to be authenticated.</li>
<li>当你设置了authenticationHandler并发出了验证玩家的请求。</li>
<li>When the app moves to the foreground.</li>
<li>当app进入foreground（前台）。</li>
<li>On sign-in, i.e., if the player has not signed in before a sign-in screen is presented, any interaction on that screen leads to the authenticationHandler being called.</li>
<li>在登录时，例如玩家在进入游戏前没有登录，进入时会弹出登录界面，在这个界面中的任何交互都会调用authenticationHandler。</li>
</ul>

The authenticationHandler has two arguments:
authenticationHandler有两个参数：
<ul>
<li>A <em>UIViewController</em> representing the login view controller if you need to present it; and</li>
<li>第一个是 <em>UIViewController</em> ，它代表如果你未登录Game Center，需要你弹出的登录view controller。</li>
<li>An <em>NSError</em> object in case authentication happens to fail.</li>
<li>还有一个 <em>NSError</em> 表示验证过程中发生的任何错误。</li>
</ul>

Notice that in the block, you first check if the local player is authenticated. If the player has already been authenticated, then all you need to do is set the _gameCenterEnabled flag as true and get on with your game.
值得注意的是，在这个block中，你首先检查玩家是否验证过了，如果玩家已经被验证了，你需要做的就是把_gameCenterEnabled变量置为true，然后就可以继续游戏了。

If the login view controller (i.e., the first parameter of the authenticationHandler) is not nil, it means that the player has not logged into Game Center. If so, you first pause the game and then present the login view controller to the player. If the player logs in or selects the Cancel button on the login view controller, this handler is called again.
如果login view controller（authenticationHandler block中的第一个参数）不为nil，就意味着玩家还没有登录Game Center。如果是这种情况，你先暂停游戏，然后为玩家弹出登录的view controller。如果玩家在此界面登录成功或者点击Cancel按钮，以上那个handler block还会被调用一次。

In earlier versions of Game Center, the developer did not have the power to decide when to present the login view controller. This new method gives developers more control, which is always a good thing. ☺
在老版本的Game Center中，开发者是没法决定何时为玩家弹出登录界面的。这个新方法给予了开发者更多可控性，来决定在何时弹出此界面。

Finally, if authentication fails you need to gracefully fall back and disable all Game Center features. This is achieved in this app by setting the <em>_gameCenterFeaturesEnabled</em> flag to false.
最终，如果验证失败了，你需要恰当的禁用所有Game Center的功能。这里通过把<em>_gameCenterFeaturesEnabled</em>变量置为false来让app无视Game Center的功能调用。

In order for the code in authenticateLocalPlayer to work, you need a few more bits of code. Add the following to <em>GameKitHelper.m</em>:
为了让authenticateLocalPlayer起作用，你还需要一些代码。在<em>GameKitHelper.m</em>中加入以下内容：

<pre lang="objc">
#pragma mark Property setters

-(void) setLastError:(NSError*)error {
    _lastError = [error copy];
    if (_lastError) {
        NSLog(@"GameKitHelper ERROR: %@", [[_lastError userInfo] 
          description]);
    }
}

#pragma mark UIViewController stuff

-(UIViewController*) getRootViewController {
    return [UIApplication 
      sharedApplication].keyWindow.rootViewController;
}

-(void)presentViewController:(UIViewController*)vc {
    UIViewController* rootVC = [self getRootViewController];
    [rootVC presentViewController:vc animated:YES 
      completion:nil];
}
</pre>

The above three methods set up a few things needed by authenticateLocalPlayer:
以上代码实现了authenticateLocalPlayer需要的三个函数：

<ol>
<li>The lastError property is declared as a readonly property. Hence, you cannot assign to it directly. So you need a setter method that will take care of setting the lastError property. That’s what setLastError: is.</li>
<li>lastError属性被声明为readonly。因此你不能在直接设置它的值，需要手动为其添加一个setter方法。这就是setLastError:的作用。</li>
<li>The Game Center login controller needs to be displayed to the user so that s/he can actually login. The presentViewController: and getRootViewController methods handle discovering the root view controller for the application and then displaying the login view via the root view controller.</li>
<li>Game Center登录controller需要真实显示出来，这样玩家才能做登录操作。presentViewController: 和 getRootViewController方法负责得到root view controller并且通过root view controller把登录界面显示出来。</li>
</ol>

Awesome! Now it’s time to put GameKitHelper to the test. Open <em>Prefix.pch</em> and add the necessary import:
太棒了！现在是时候测试一下GameKitHelper了。打开<em>Prefix.pch</em>并加入必要的import：

<pre lang="objc">
#import "GameKitHelper.h"
</pre>

Next, open <em>MenuLayer.m</em> and add the following code to onEnter (right below the initial [super onEnter]). This will authenticate the player every time the menu screen is presented
接下来，打开<em>MenuLayer.m</em>并在onEnter（紧跟在[super onEnter]语句之后）中加入如下内容。每当主界面显示的时候都会验证玩家。

<pre lang="objc">
[[GameKitHelper sharedGameKitHelper]
                authenticateLocalPlayer];
</pre>

Build and run the application, and now when the menu view controller appears you will see one of the following screens:
编译并运行。当主菜单显示出来的时候你会看到以下的内容：

<a href="http://www.raywenderlich.com/?attachment_id=23244" rel="attachment wp-att-23244"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/game_center_login-700x230.png" alt="" title="game_center_login" width="700" height="230" class="alignnone size-large wp-image-23244" /></a>

The image on the left shows the login view controller, presented in case the user was not logged in with Game Center. The image on the right shows the welcome banner, displayed every time an authentication call is successful.
左边的图示演示了登录view controller（玩家未登录Game Center的情况）。右边的演示了welcome banner，每当验证成功时就会弹出。

<div class="note"><p><em>Note:</em> To test the authentication, first logout of Game Center and then login through the MonkeyJump app. This will run Game Center in sandbox mode. Additionally, this probably will not work on the Simulator (at least, it didn’t work at the time of writing). You would need to test this on an actual device.</p></div>
<div class="note"><p><em>注意：</em> 为了测试验证过程，首先登出Game Center然后再在MonkeyJump app里登录。只有这样才能在沙盒模式下运行Game Center。另外，在模拟器上运行也许行不通（至少在写这篇教程时还不行）。你需要在真机上进行测试。</p></div>

<h2>Submitting scores to Game Center</h2>
<h2>提交分数到Game Center</h2>

To send a score to Game Center, use the <em>GKScore</em> class. This class holds information about the player’s score and the category to which it belongs.
若提交一个分数到Game Center，需要使用<em>GKScore</em>类。这个类保存着有关玩家分数和分数所属类别的信息。

The category refers to the leaderboard ID. For example, if you wish to submit a score to the High Scores leaderboard, then the category of the <em>GKScore</em> object would be the leaderboard ID that you set in iTunes Connect, which in your case is HighScores.
类别指的是leaderboard ID。例如，你希望提交一个分数到High Scores排行榜，那么<em>GKScore</em>对象的category就应该是你在iTues Connect设置的那个leaderboard ID，这里就是HighScores。

Open <em>GameKitHelper.h</em> and add the following method declaration:
打开<em>GameKitHelper.h</em>并加入以下方法声明：

<pre lang="objc">
// Scores
-(void) submitScore:(int64_t)score
           category:(NSString*)category;
</pre>

Next, add the following method declaration to GameKitHelperProtocol:
接下来，在GameKitHelperProtocol中加入以下方法声明：

<pre lang="objc">
-(void) onScoresSubmitted:(bool)success;
</pre>

Now open <em>GameKitHelper.m</em> and add the following code:
打开<em>GameKitHelper.m</em>并加入以下代码：

<pre lang="objc">
-(void) submitScore:(int64_t)score
        category:(NSString*)category {
    //1: Check if Game Center
    //   features are enabled
    if (!_gameCenterFeaturesEnabled) {
        CCLOG(@"Player not authenticated");
        return;
    }
    
    //2: Create a GKScore object
    GKScore* gkScore =
            [[GKScore alloc]
                initWithCategory:category];
    
    //3: Set the score value
    gkScore.value = score;
    
    //4: Send the score to Game Center
    [gkScore reportScoreWithCompletionHandler:
               ^(NSError* error) {
                               
        [self setLastError:error];

        BOOL success = (error == nil);
                               
        if ([_delegate
                respondsToSelector:
                @selector(onScoresSubmitted:)]) {
            
            [_delegate onScoresSubmitted:success];
        }
     }];
}
</pre>

Here’s a step-by-step explanation of the above method:
以下是上面方法的分步说明：

<ol>
<li>Check to see if Game Center features are enabled, and execution proceeds only if they are.</li>
<li>检查Game Center功能是否启用了，只有当启用时再执行之后的代码。</li>
<li>Create an instance of <em>GKScore</em>. The category used to create an object of <em>GKScore</em> is passed as an argument to the method.</li>
<li>创建一个<em>GKScore</em>的实例。<em>GKScore</em>所需要的分数所属类别作为init方法的参数传入。</li>
<li>Set the value of the <em>GKScore</em> object.</li>
<li>设置<em>GKScore</em>的分数值。</li>
<li>Send the <em>GKScore</em> object to Game Center using the reportScoreWithCompletionHandler: method. Once the score is sent, the platform calls the completion handler. The completion handler is a block that has one argument, in this case an NSError object that you can use to find out if the score was submitted successfully.</li>
<li>使用reportScoreWithCompletionHandler:方法把<em>GKScore</em>对象发送到Game Center端。当分数被发送后，平台会调用completion handler。completion handler是一个只有一个参数的block，在这里是一个NSError 对象，你可以通过它来查看分数是否发送成功了。</li>
</ol>

Now that you have defined a method to submit a score to Game Center, its time to use it! But before you do that, open <em>GameConstants.h</em> and add the following define statement at the end (before the last #endif):
现在你已经有了发送分数到Game Center的方法了，是时候使用它了。在使用该方法之前，打开<em>GameConstants.h</em>并在文件末尾（但在最后的#endif之前）加入以下define语句：

<pre lang="objc">
#define kHighScoreLeaderboardCategory @"HighScores"
</pre>

Next, open <em>GameLayer.m</em> and find the method named monkeyDead. As the name implies, this method is called when the monkey dies. In other words, this is where the game would end.
然后，打开<em>GameLayer.m</em>并找到monkeyDead方法。根据此方法的名字透露的信息，这个方法是在猴子挂掉时调用的。换句话说，就是游戏结束的时候。

Add the following code as the first line in the method:
在该方法的开头加入以下语句：

<pre lang="objc">
[[GameKitHelper sharedGameKitHelper]
        submitScore:(int64_t)_distance
        category:kHighScoreLeaderboardCategory];
</pre>

Now build and run the app. Play the game until the monkey dies. Poor little dude!
编译并运行。玩儿一遍游戏直到猴子挂掉。可怜的小家伙！

When you finish playing, your score will be sent to Game Center. To verify that everything is working, open the Game Center app, tap on the Games tab and select the MonkeyJump game. The leaderboard should show your score. Here is a screenshot of Game Center showing the HighScores leaderboard:
当你玩儿完后，你的分数会被发送到Game Center。为了验证是否真的发送成功了，打开Game Center app，点击Games分页并选择MonkeyJump。这里的排行榜会显示你的分数。下边是HighScores排行榜的截图示例：

<a href="http://www.raywenderlich.com/?attachment_id=23243" rel="attachment wp-att-23243"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/game_center_app_leaderboard-213x320.png" alt="" title="game_center_app_leaderboard" width="213" height="320" class="alignnone size-medium wp-image-23243" /></a>

Did you beat my score? No hacking the source code, now! :]
你打败我的分数了吗？不要使用改代码的作弊手段哦！:]

<h2>Game Center challenges</h2>
<h2>Game Center 挑战</h2>

Finally - the section you’ve been waiting for!
终于到了你期待已久的部分了！

Game Center challenges is the biggest new Game Center feature introduced in iOS 6.0. Challenges can help make your game go viral, and they increase user retention tremendously. 
Game Center 挑战是iOS 6.0 的 Game Center中引入的最大的功能。挑战可以让你的游戏病毒式地传播，而且还可以极大的增加玩家的留存。

The only problem is, integrating challenges is extremely difficult since the API is vast and complicated.
但是问题是，使用挑战功能是一件异常艰难并且复杂的工作，因为它有着数量广袤的的API而且非常复杂（作者开玩笑说的）。

<a href="http://www.raywenderlich.com/?attachment_id=23249" rel="attachment wp-att-23249"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/lol_game_center_tough.png" alt="" title="lol_game_center_tough" width="165" height="174" class="alignnone size-full wp-image-23249" /></a>

Just kidding! To integrate challenges into your game, all you have to do is… ABSOLUTELY NOTHING! ☺ If your game supports leaderboards or achievements, it will automatically support challenges without you having to do any extra work.
只是开个玩笑啦！把挑战功能集成到你的游戏中，所有要做的仅仅是...完全不需要任何工作！☺如果你的游戏支持leaderboards或者achievements，那么你的游戏就会自动的支持challenges（挑战），而不需要做任何额外的工作。

<a href="http://www.raywenderlich.com/?attachment_id=23248" rel="attachment wp-att-23248"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/lol_game_center_easy.png" alt="" title="lol_game_center_easy" width="161" height="176" class="alignnone size-full wp-image-23248" /></a>

To test this, open the Game Center application (make sure you are in sandbox mode). Go to the Games tab and open the MonkeyJump game.
为了测试这个，打开Game Center程序（确保你是在沙盒模式下）。进入Games分页并打开MonkeyJump游戏。

If you have played the game a few times select your high score from the leaderboard. You will see a Challenge Friends button in the detail. Tap on it, enter the names of friends you want to challenge and press Send. When the challenge is sent, your friends will receive a push notification.
如果你已经玩儿了有几次游戏，从leaderboard中选择你的高分。你会看到在一个Challenge Friends的按钮出现在详细信息界面。点击它，输入想要挑战的好友的名字，点击Send。当challenge被成功发送后，你的好友会收到一个push notification。

<div class="note"><p><em>Note:</em> To test challenges, you will need two devices running iOS 6.0, each logged into Game Center with a different account, and the accounts need to have added each other as friends.</p></div>
<div class="note"><p><em>注意：</em> 为了测试challenges，你需要两台运行iOS 6.0的设备，每台都需要登入不同的Game Center帐号，并且互相之间要加为好友。</p></div>

Challenges are not mere push notifications. Let me briefly explain how challenges work with an example.
Challenges绝不仅仅是push notifications而已。让我通过一个例子来详细地为你说明它。

Suppose I send a score challenge to Ray of 500 meters. Ray will receive a push notification on his device informing him of the challenge. Let’s suppose he gets a score of 1000 meters when he plays the game. In other words, Ray wipes the floor with the challenge. And he definitely wants me to know about that.
假如我给Ray发送了一个500米成绩的挑战。Ray会在他的设备上接收到一个通知他此挑战的push notification。我们假设Ray在回应挑战的游戏中得到了1000米的成绩。也就是说Ray挑战成功了。那么他当然想让我知道这件事儿。

Since the game reports all scores to Game Center, it knows automatically that Ray killed the challenge, so it will send a challenge completion push notification to both the devices. Ray can then challenge me with his 1000 meter score. Little does he know that I can do 1000 meters in my sleep. 
由于游戏是把所有分数发送到Game Center上的，Game Center自动地获取到Ray挑战成功了，所以它会同时发送一个挑战完成的push notification到两个人的设备上去。Ray之后还可以以1000米这个分数向我发起挑战。他一定不知道我再梦里也能跑1000米吧。

<a href="http://www.raywenderlich.com/?attachment_id=23236" rel="attachment wp-att-23236"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/challenge_accepted.png" alt="" title="challenge_accepted" width="277" height="258" class="alignnone size-full wp-image-23236" /></a>

This process can go on indefinitely, with each party repeatedly topping the other’s score. It is because of this addictive, self-perpetuating use pattern that every game developer should integrate challenges into his/her games!
这个过程可以无穷尽的持续下去，每一次一方都会超过另一方的分数。这样就会让人很上瘾，这种自我延续的特性使得每个游戏开发者都应该在他/她的游戏中集成challenge。

Up until now, you’ve tested challenges using the Game Center application, but what if you want to allow the user to challenge his/her friends from within your game? 
到现在为止，你已经在Game Center应用中测试了challenge，但是怎么样才能允许玩家在游戏内也能想他/她的好友发起挑战呢？

That’s exactly what you’re going to do next. :] You will add this functionality to your game and allow the player to select which friends s/he wants to challenge using a friend picker.
这就是接下来要做的。:]你将要在你的游戏中添加一个朋友选择器，允许玩家选择他/她的好友，并发送挑战。

Open <em>GameKitHelper.h</em> and add a new property to it.
打开<em>GameKitHelper.h</em>并加入一个新的属性。

<pre lang="objc">
@property (nonatomic, readwrite)
        BOOL includeLocalPlayerScore;
</pre>

Next add the following method declarations to <em>GameKitHelperProtocol</em>:
接下来在<em>GameKitHelperProtocol</em>加入以下方法声明：

<pre lang="objc">
-(void) onScoresOfFriendsToChallengeListReceived:
            (NSArray*) scores;
-(void) onPlayerInfoReceived:
            (NSArray*)players;
</pre>

Also add these method declarations to <em>GameKitHelper</em>:
同时在<em>GameKitHelper</em>中加入以下方法声明：

<pre lang="objc">
-(void) findScoresOfFriendsToChallenge;

-(void) getPlayerInfo:(NSArray*)playerList;

-(void) sendScoreChallengeToPlayers:
        (NSArray*)players
        withScore:(int64_t)score
        message:(NSString*)message;
</pre>

Next you’re going to define each one of the above methods in <em>GameKitHelper.m</em>. Let’s start with findScoresOfFriendsToChallenge. Add the following lines of code:
然后在<em>GameKitHelper.m</em>中定义以上的方法。让我们从findScoresOfFriendsToChallenge开始。添加以下内容：

<pre lang="objc">
-(void) findScoresOfFriendsToChallenge {
    //1
    GKLeaderboard *leaderboard =
            [[GKLeaderboard alloc] init];
    
    //2
    leaderboard.category =
            kHighScoreLeaderboardCategory;
    
    //3
    leaderboard.playerScope =
            GKLeaderboardPlayerScopeFriendsOnly;
    
    //4
    leaderboard.range = NSMakeRange(1, 100);
    
    //5
    [leaderboard
        loadScoresWithCompletionHandler:
        ^(NSArray *scores, NSError *error) {
            
        [self setLastError:error];
            
        BOOL success = (error == nil);
            
        if (success) {
            if (!_includeLocalPlayerScore) {
                NSMutableArray *friendsScores =
                        [NSMutableArray array];
                
                for (GKScore *score in scores) {
                    if (![score.playerID
                          isEqualToString:
                          [GKLocalPlayer localPlayer]
                          .playerID]) {
                        [friendsScores addObject:score];
                    }
                }
                scores = friendsScores;
            }
            if ([_delegate
                 respondsToSelector:
                 @selector
                 (onScoresOfFriendsToChallengeListReceived:)]) {
                
              [_delegate
               onScoresOfFriendsToChallengeListReceived:scores];
            }
        }
    }];
}
</pre>

This method is responsible for fetching the scores of all the player’s friends. To do this, the method queries the HighScores leaderboard for scores of the local player’s friends.
这个方法负责获取玩家的所有好友的分数。通过查询HighScores leaderboard获取玩家的好友分数。

Every time you request scores, Game Center adds the score of the local player to the results by default. For example, in the above method when you request the scores of all the player’s friends, Game Center returns an array containing not only the scores of the player’s friends, but the player’s score as well. So, you use the  includeLocalPlayerScore property to decide whether or not to remove the local player’s score from the scores array. By default, this is NO (don’t include the player’s score).
每次你查询分数，Game Center都会默认添加本地玩家的分数进去。例如上边的方法，当你获取所有好友的分数的同时，Game Center返回的数组不但包含所有玩家好友的，也会包含玩家自身的分数。所以这里你使用了includeLocalPlayerScore属性来决定是否要添加玩家自己的分数到返回结果中，默认的这个值是NO（不包含玩家的分数）。

Now add the following method:
现在添加以下方法：

<pre lang="objc">
-(void) getPlayerInfo:(NSArray*)playerList {
    //1
    if (_gameCenterFeaturesEnabled == NO)
        return;
    
    //2
    if ([playerList count] > 0) {
        [GKPlayer
            loadPlayersForIdentifiers:
            playerList
            withCompletionHandler:
                 ^(NSArray* players, NSError* error) {
             
                 [self setLastError:error];
             
                 if ([_delegate
                          respondsToSelector:
                          @selector(onPlayerInfoReceived:)]) {
                
                     [_delegate onPlayerInfoReceived:players];
            }
         }];
     }
}
</pre>

This method gets player information for a list of players by passing in an array of player IDs.
此方法通过传入一个玩家ID的数组来获得这些玩家的信息。

One final method – add the following code:
还有最后一个方法 - 添加以下代码：

<pre lang="objc">
-(void) sendScoreChallengeToPlayers:
    (NSArray*)players
    withScore:(int64_t)score
    message:(NSString*)message {
    
    //1
    GKScore *gkScore =
        [[GKScore alloc]
            initWithCategory:
            kHighScoreLeaderboardCategory];
    gkScore.value = score;
    
    //2
    [gkScore issueChallengeToPlayers:
            players message:message];
}
</pre>

This method sends out a score challenge to a list of players, accompanied by a message from the player.
此方法想一组玩家发送一个分数挑战，同时还跟随着一条玩家发送的消息。

Great! Next, you need a friend picker. The friend picker will allow the player to enter a custom message and select the friends that s/he wants to challenge. By default, it will select those friends that have a score lower than the local player’s score, since these are the ones that the player should definitely challenge. After all, the player wants to win! ☺
很好！接下来，你需要一个friend picker(玩家选择器)。friend picker将会允许玩家输入一条自定义的消息并选择他/她想要发送挑战的玩家们。默认情况下，它会选择那些当前分数比你低的玩家，因为这些人玩家理所应当向他们发送挑战。毕竟每个玩家都希望赢！☺

Create a new group in Xcode and name it ViewControllers. Then create a new file in that group that extends UIViewController and name it <em>FriendsPickerViewController</em>. Make sure you check the “With XIB for user interface” checkbox, as shown below
在Xcode中新建一个group并命名为ViewControllers。然后新建一个继承自UIViewController的文件并将其命名为<em>FriendsPickerViewController</em>。注意这里要选中“With XIB for user interface”。如下所示：

<a href="http://www.raywenderlich.com/?attachment_id=23240" rel="attachment wp-att-23240"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/friends_picker_view_controller_class.png" alt="" title="friends_picker_view_controller_class" width="666" height="450" class="alignnone size-full wp-image-23240" /></a>

Open the <em>FriendsPickerViewController.xib</em> file, set the view’s orientation to landscape, drag a UITableView, a UITextField and a UILabel onto the canvas, and set the text property of the label as “Challenge message”. 
打开<em>FriendsPickerViewController.xib</em>文件，设置view's orientation为landscape，拖拽进来一个UITableView，一个UITextField和一个UILabel到canvas中，设置label的text属性为“Challenge message”。

Also, to make sure that this view controller has the same look and feel as the rest of the game, add bg_menu.png as the background image. The final view controller should look like this:
另外，为了让次界面看起来和游戏的其他界面相吻合，添加bg_menu.png作为背景图片。最终的view controller看起来如下图所示：

<a href="http://www.raywenderlich.com/?attachment_id=23241" rel="attachment wp-att-23241"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/friends_picker_view_controller_lf.png" alt="" title="friends_picker_view_controller_l&amp;f" width="513" height="355" class="alignnone size-full wp-image-23241" /></a>

Open <em>FriendsPickerViewController.h</em> and add the following statements above the @interface line:
打开<em>FriendsPickerViewController.h</em>并在@interface添加如下语句：

<pre lang="objc">
typedef void
        (^FriendsPickerCancelButtonPressed)();
typedef void
        (^FriendsPickerChallengeButtonPressed)();
</pre>

These two new data types, FriendsPickerCancelButtonPressed and FriendsPickerChallengeButtonPressed, describe the blocks you’ll be using. A block is like a C function; it has a return type (in this case void) and zero or more parameters. The typedef makes it a bit easier to refer to this block in the code.
这两个新的数据类型，FriendsPickerCancelButtonPressed 和 FriendsPickerChallengeButtonPressed，是你将要使用的两种block。block类似C函数，它有返回类型（这里是void）和零个或多个参数。typedef定义使之后在代码中使用此block更为简化。

Add the following properties to the @interface section:
添加如下属性到@interface部分：

<pre lang="objc">
//1
@property (nonatomic, copy)
    FriendsPickerCancelButtonPressed
    cancelButtonPressedBlock;

//2
@property (nonatomic, copy)
    FriendsPickerChallengeButtonPressed
    challengeButtonPressedBlock;
</pre>

These properties represent blocks of code that will be executed when either the Cancel or the Challenge buttons are pressed.
这些属性是将来Cancel或者Challenge按钮按下时所执行的block。

Next add the Cancel and Challenge buttons to the view controller. Open <em>FriendsPickerViewController.m</em> and replace viewDidLoad with the following code:
接下来添加Cancel和Challenge按钮到view controller中。打开<em>FriendsPickerViewController.m</em>并替换viewDidLoad为以下代码：

<pre lang="objc">
- (void)viewDidLoad {
    [super viewDidLoad];
    
    UIBarButtonItem *cancelButton =
        [[UIBarButtonItem alloc]
         initWithTitle:@"Cancel"
         style:UIBarButtonItemStylePlain
         target:self
         action:@selector(cancelButtonPressed:)];
    
    UIBarButtonItem *challengeButton =
        [[UIBarButtonItem alloc]
         initWithTitle:@"Challenge"
         style:UIBarButtonItemStylePlain
         target:self
         action:@selector(challengeButtonPressed:)];
    
    self.navigationItem.leftBarButtonItem =
        cancelButton;
    self.navigationItem.rightBarButtonItem =
        challengeButton;
}
</pre>

The method adds two UIBarButtonItems to the view controller, representing the Cancel and Challenge buttons. Now add the methods that will be called when these buttons are tapped.
此方法添加了两个UIBarButtonItems到view controller中，分别是Cancel和Challenge按钮。现在添加当这两个按钮被按下时所触发的方法。

<pre lang="objc">
- (void)cancelButtonPressed:(id) sender {
    if (self.cancelButtonPressedBlock != nil) {
        self.cancelButtonPressedBlock();
    }
}

- (void)challengeButtonPressed:(id) sender {
    if (self.challengeButtonPressedBlock) {
            self.challengeButtonPressedBlock();
    }
}
</pre>

The above methods are easy to understand – all you do is execute the code in the challenge and cancel blocks.
上边的方法很好理解，你所做的就是在函数中执行challenge和cancel的block。

Before you can integrate this view controller into the game and test to see if everything works, you first need to write an initialization method that takes the score of the local player. But before you do this, you must define a variable to hold the score.
在你把此view controller集成到游戏中并验证一切正常之前，你需要先写一个初始化方法来获取本地玩家的分数。在完成这一步之前，你先要定义一个变量存储此分数。

Add the following variable to the class extension at the top of <em>FriendsPickerViewController.m</em> – and remember to enclose the variable in curly brackets so that the final class extension looks like this: 
在<em>FriendsPickerViewController.m</em>中的类extension块儿中添加以下变量 - 记得要在变量之间插入花括号，最终的类extension看起来如下所示：

<pre lang="objc">
@interface FriendsPickerViewController () {
    int64_t _score;
}
@end
</pre>

Now add the following initialization method:
现在添加如下的初始化方法：

<pre lang="objc">
- (id)initWithScore:(int64_t) score {
    self = [super
            initWithNibName:
            @"FriendsPickerViewController"
            bundle:nil];
    
    if (self) {
        _score = score;
    }
    return self;
}
</pre>

Add the method declaration for the above to <em>FriendsPickerViewController.h</em>, as shown below:
在<em>FriendsPickerViewController.h</em>中添加该方法声明，如下所示：

<pre lang="objc">
-(id)initWithScore:(int64_t) score;
</pre>

Now you are ready to test this view controller to see if everything works as expected. Open <em>GameKitHelper.h</em> and define a method as follows:
现在你就可以测试以下此view controller了，看看它是不是如预期一样工作正常。打开<em>GameKitHelper.h</em>并定义一个如下方法：

<pre lang="objc">
-(void)
    showFriendsPickerViewControllerForScore:
    (int64_t)score;
</pre>

Then open <em>GameKitHelper.m</em> and add the following import statement:
然后打开<em>GameKitHelper.m</em>并添加如下import语句：

<pre lang="objc">
#import "FriendsPickerViewController.h"</pre>

Next, add the method as follows:
然后，添加如下方法：

<pre lang="objc">
-(void)
    showFriendsPickerViewControllerForScore:
    (int64_t)score {
    
    FriendsPickerViewController
        *friendsPickerViewController =
                [[FriendsPickerViewController alloc]
                 initWithScore:score];
    
    friendsPickerViewController.
        cancelButtonPressedBlock = ^() {
        [self dismissModalViewController];
    };
    
    friendsPickerViewController.
        challengeButtonPressedBlock = ^() {
        [self dismissModalViewController];
    };
    
    UINavigationController *navigationController =
        [[UINavigationController alloc]
            initWithRootViewController:
            friendsPickerViewController];
    
    [self presentViewController:navigationController];
}
</pre>

This method presents the FriendPickerViewController modally. It also defines the blocks that will be executed when the Challenge and Cancel buttons are pressed. In this case, all that happens is that the view controller is dismissed.
此方法会模态地弹出FriendPickerController。它还定义了当Challeng和Cancel按钮被按下时触发的block。目前它们只是简单的使该界面消失。

Now open <em>GameOverLayer.m</em> and replace the CCLOG(@"Challenge button pressed"); line in menuButtonPressed: with the following:
打开<em>GameOverLayer.m</em>并把menuButtonPressed:中的CCLOG(@"Challenge button pressed");行替换为以下内容：

<pre lang="objc">
[[GameKitHelper sharedGameKitHelper]
            showFriendsPickerViewControllerForScore:_score];
</pre>

Here is the moment of truth! Build and run the game, play a round of MonkeyJump, and when you press the Challenge Friends button on the game over screen, you will be presented with the FriendsPickerViewController. If you tap on either the Challenge or the Cancel button the view controller will be dismissed.
到了关键时刻了！编译并运行，玩儿一局MonkeyJump，在game over屏点击Challenge Friends按钮，你会看到FriendsPickerViewController弹出来了。如果你点击不论Challenge还是Cancel按钮都会使该界面消失。

<a href="http://www.raywenderlich.com/?attachment_id=23251" rel="attachment wp-att-23251"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/show_friends_picker_view_controller.png" alt="" title="show_friends_picker_view_controller" width="532" height="355" class="alignnone size-full wp-image-23251" /></a>

Great! Your game now has the ability to show the friends picker view controller. But the view controller does not show any friends, which kind of defeats the purpose.
很好！你的游戏现在有了好友选择的界面了。但是这个界面还没显示任何的好友，这样是不行的。

No need to feel lonely – let’s add this functionality!
没必要感觉孤单,我们这就加入此功能！

Open <em>FriendsPickerViewController.m</em> and replace the class extension with the following:
打开<em>FriendsPickerViewController.m</em>并把类extension替换为以下内容：

<pre lang="objc">
@interface FriendsPickerViewController ()
        <UITableViewDataSource,
        UITableViewDelegate,
        UITextFieldDelegate,
        GameKitHelperProtocol> {
            
    NSMutableDictionary *_dataSource;
    int64_t _score;
}
@property (nonatomic, weak)
        IBOutlet UITableView *tableView;
@property (nonatomic, weak)
        IBOutlet UITextField *challengeTextField;
@end
</pre>

Notice that the interface now implements a bunch of protocols. Along with that, it also has two IBOutlets, one for the UITableView and the other for the UITextfield. Connect these properties to their respective views using Interface Builder, as shown below:
注意这里的interface部分实现了很多的protocol。同时，它还有两个IBOutlet，一个是UITableView的，另一个是UITextfield的。使用Interface Builder把它们和相应的view关联起来，如下所示：

<a href="http://www.raywenderlich.com/?attachment_id=23238" rel="attachment wp-att-23238"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/datasource_delegate_connections_friends_picker_view_controller.png" alt="" title="datasource_delegate_connections_friends_picker_view_controller" width="788" height="370" class="alignnone size-full wp-image-23238" /></a>

Next set the delegate and the data source of the UITableView, and the delegate of the UITextField, as the File’s Owner in Interface Builder.
接下来设置UITableView的delegate和data source，还有UITextField的delegate，在Interface Builder中把它们都设置为File's Owner。

To do this, select the UITableView and in the Connections inspector, drag the data source and delegate outlets to the File’s Owner on the left, as shown in the image below:
为了完成这个，首先选择UITableView，在Connections inspector中，把data source和delegate outlet分别拖拽到左侧的File's Owner，如下图所示：

<a href="http://www.raywenderlich.com/?attachment_id=23252" rel="attachment wp-att-23252"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/textfield_delegate.png" alt="" title="textfield_delegate" width="788" height="385" class="alignnone size-full wp-image-23252" /></a>

Repeat the process for the UITextField.
为UITextField重复此步骤。

Switch to <em>FriendsPickerViewController.m</em> and add the following code within the if condition in initWithScore:, below the _score = score; line:
切换到<em>FriendsPickerViewController.m</em>并在initWithScore:方法的if语句中的_score = score;行之后添加如下代码：

<pre lang="objc">
dataSource = [NSMutableDictionary dictionary];
        
GameKitHelper *gameKitHelper = [GameKitHelper sharedGameKitHelper];
        
gameKitHelper.delegate = self;
[gameKitHelper findScoresOfFriendsToChallenge];   
</pre>

This method initializes the data source, sets itself as the delegate for GameKitHelper, and calls findScoresOfFriendsToChallenge. If you recall, this method is used to find the scores of all the friends of the local player. Implement the onScoresOfFriendsToChallengeListReceived: delegate method to handle what happens after the player’s friends’ scores are fetched:
此方法初始化了data source，设置其自身为GameKitHelper的delegate并调用findScoresOfFriendsToChallenge。如果你还记得，这个方法是用来获取本地玩家所有好友的分数的。接下来需要实现onScoresOfFriendsToChallengeListReceived:代理方法，来处理当玩家的分数获取到后的事件：

<pre lang="objc">
-(void)
    onScoresOfFriendsToChallengeListReceived:
    (NSArray*) scores {
    //1
    NSMutableArray *playerIds =
        [NSMutableArray array];
    
    //2
    [scores enumerateObjectsUsingBlock:
        ^(id obj, NSUInteger idx, BOOL *stop){
            
        GKScore *score = (GKScore*) obj;
        
        //3    
        if(_dataSource[score.playerID]
                                == nil) {
            _dataSource[score.playerID] =
                    [NSMutableDictionary dictionary];
            [playerIds addObject:score.playerID];
        }
        
        //4
        if (score.value < _score) {
            [_dataSource[score.playerID]
                    setObject:[NSNumber numberWithBool:YES]
                    forKey:kIsChallengedKey];
        }
        
        //5
        [_dataSource[score.playerID]
                    setObject:score forKey:kScoreKey];
    }];
    
    //6
    [[GameKitHelper sharedGameKitHelper]
                    getPlayerInfo:playerIds];
    [self.tableView reloadData];
}
</pre>

The code is quite self-explanatory, but here’s an explanation anyway:
以上代码有很强的自说明性，不过还是按步骤解释一下：
<ol>
<li>An array named playerIds is created to hold the IDs of the local player’s friends.</li>
<li>创建一个名为playerIds的数组用来存储本地玩家所有好友的ID。</li>
<li>Then the method starts iterating over the returned scores.</li>
<li>然后此方法开始遍历返回的分数。</li>
<li>For each score, an entry in the data source is created and the player ID is stored in the playerIds array.</li>
<li>对每一个分数，都在data source中创建相应的数据，并且在playerIds数组中保存player ID。</li>
<li>If the score is less than the local player’s score, the entry is marked in the data source.</li>
<li>如果这个分数比本地玩家的分数低，该分数对应的在data source中的数据会被标记。</li>
<li>The score is stored in the data source dictionary.</li>
<li>分数被保存在data source字典中。</li>
<li>The GameKitHelper’s getPlayerInfo: method is invoked with the playerIds array. This will return the details of each friend, such as the player’s name and profile picture.</li>
<li>GameKitHelper的getPlayerInfo:方法调用时使用playerIds数组作为参数。该方法会返回每个好友的详细信息，比如好友的名字和头像。</li>
</ol>

The above method requires a few #defines in order to work. Add those (and a few others you’ll need later on in the code) to the top of the file below the #import line:
以上代码需要一些#define语句才能正常工作，在文件头#import行之后，加入以下内容（有些是以后会用到的）：

<pre lang="objc">
#define kPlayerKey @"player"
#define kScoreKey @"score"
#define kIsChallengedKey @"isChallenged"

#define kCheckMarkTag 4
</pre>

Next you need to implement the onPlayerInfoReceived: delegate method. This method is called when information for all the local player’s friends has been received.
然后你需要实现onPlayerInfoReceived:代理方法。这个方法会在本地玩家所有好友的信息获取到之后调用。

<pre lang="objc">
-(void) onPlayerInfoReceived:(NSArray*)players {
    //1
    
    [players
        enumerateObjectsUsingBlock:
        ^(id obj, NSUInteger idx, BOOL *stop) {
            
        GKPlayer *player = (GKPlayer*)obj;
        
        //2
        if (_dataSource[player.playerID]
                                == nil) {
            _dataSource[player.playerID] =
                    [NSMutableDictionary dictionary];
        }
        [_dataSource[player.playerID]
                    setObject:player forKey:kPlayerKey];

        //3
        [self.tableView reloadData];
    }];
}
</pre>

This method is also quite straightforward; since you have the details of each player, you just update the _dataSource dictionary with each player’s information. 
这个方法也非常直接了当，因为你有每个玩家的详细信息，你只需要更新每个玩家的_dataSource字典即可。

The _dataSource dictionary is used to populate the table view. Implement the table view’s data source methods as shown below:
_dataSource字典用来作为table view的数据源。接下来实现table view的data source方法，如下所示：

<pre lang="objc">
- (NSInteger)tableView:(UITableView *)tableView
        numberOfRowsInSection:(NSInteger)section {
    return _dataSource.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    static NSString *CellIdentifier = @"Cell identifier";
    static int ScoreLabelTag = 1;
    static int PlayerImageTag = 2;
    static int PlayerNameTag = 3;
    
    UITableViewCell *tableViewCell =
        [tableView
            dequeueReusableCellWithIdentifier:
            CellIdentifier];
    
    if (!tableViewCell) {
        
        tableViewCell =
            [[UITableViewCell alloc]
             initWithStyle:UITableViewCellStyleDefault
             reuseIdentifier:CellIdentifier];
        tableViewCell.selectionStyle =
            UITableViewCellSelectionStyleGray;
        tableViewCell.textLabel.textColor =
            [UIColor whiteColor];
        
        UILabel *playerName =
            [[UILabel alloc] initWithFrame:
             CGRectMake(50, 0, 150, 44)];
        playerName.tag = PlayerNameTag;
        playerName.font = [UIFont systemFontOfSize:18];
        playerName.backgroundColor =
            [UIColor clearColor];
        playerName.textAlignment =
            UIControlContentVerticalAlignmentCenter;
        [tableViewCell addSubview:playerName];
        
        UIImageView *playerImage =
                [[UIImageView alloc]
                initWithFrame:CGRectMake(0, 0, 44, 44)];
        playerImage.tag = PlayerImageTag;
        [tableViewCell addSubview:playerImage];
        
        UILabel *scoreLabel =
                [[UILabel alloc]
                initWithFrame:
                 CGRectMake(395, 0, 30,
                        tableViewCell.frame.size.height)];
        
        scoreLabel.tag = ScoreLabelTag;
        scoreLabel.backgroundColor =
                    [UIColor clearColor];
        scoreLabel.textColor =
                    [UIColor whiteColor];
        [tableViewCell.contentView
                    addSubview:scoreLabel];
        
        UIImageView *checkmark =
                [[UIImageView alloc]
                 initWithImage:[UIImage
                 imageNamed:@"checkmark.png"]];
        checkmark.tag = kCheckMarkTag;
        checkmark.hidden = YES;
        CGRect frame = checkmark.frame;
        frame.origin =
               CGPointMake(tableView.frame.size.width - 16, 13);
        checkmark.frame = frame;
        [tableViewCell.contentView
                addSubview:checkmark];
    }
    NSDictionary *dict =
        [_dataSource allValues][indexPath.row];
    GKScore *score = dict[kScoreKey];
    GKPlayer *player = dict[kPlayerKey];
    
    NSNumber *number = dict[kIsChallengedKey];
    
    UIImageView *checkmark =
            (UIImageView*)[tableViewCell
                           viewWithTag:kCheckMarkTag];
    
    if ([number boolValue] == YES) {
        checkmark.hidden = NO;
    } else {
        checkmark.hidden = YES;
    }
    
    [player
        loadPhotoForSize:GKPhotoSizeSmall
        withCompletionHandler:
        ^(UIImage *photo, NSError *error) {
        if (!error) {
            UIImageView *playerImage =
            (UIImageView*)[tableView
                           viewWithTag:PlayerImageTag];
            playerImage.image = photo;
        } else {
            NSLog(@"Error loading image");
        }
    }];
    
    UILabel *playerName =
        (UILabel*)[tableViewCell
                      viewWithTag:PlayerNameTag];
    playerName.text = player.displayName;
    
    UILabel *scoreLabel =
        (UILabel*)[tableViewCell
                      viewWithTag:ScoreLabelTag];
    scoreLabel.text = score.formattedValue;
    return tableViewCell;
}
</pre>

That’s a lot of code. :] But if you have used a UITableView before, the code should not be new to you. The tableView:cellForRowAtIndex: method creates a new UITableViewCell. Each cell of the table view will contain a profile picture, the player’s name and the player’s score.
好多的代码啊。:]但是你之前使用过UITableView，这些代码对你并不陌生。tableView:cellForRowAtIndex:创建一个新的UITableViewCell。每个table view中的cell都会包含一个头像，玩家的名字和分数。

Now add tableView:didSelectRowAtIndex: to handle the user selecting a row in the table view:
现在添加tableView:didSelectRowAtIndex:来处理用户选择table view中每一行的事件：

<pre lang="objc">
- (void)tableView:(UITableView *)tableView
    didSelectRowAtIndexPath:
    (NSIndexPath *)indexPath {
    
    BOOL isChallenged = NO;
    
    //1
    UITableViewCell *tableViewCell =
            [tableView cellForRowAtIndexPath:
                indexPath];
    
    //2
    UIImageView *checkmark =
            (UIImageView*)[tableViewCell
                viewWithTag:kCheckMarkTag];
    
    //3
    if (checkmark.isHidden == NO) {
        checkmark.hidden = YES;
    } else {
        checkmark.hidden = NO;
        isChallenged = YES;
    }
    NSArray *array =
        [_dataSource allValues];
    
    NSMutableDictionary *dict =
        array[indexPath.row];
    
    //4
    [dict setObject:[NSNumber
                     numberWithBool:isChallenged]
                     forKey:kIsChallengedKey];
    [tableView deselectRowAtIndexPath:indexPath
               animated:YES];
}
</pre>

All the method does is set an entry in the _dataSource to YES or NO. 
这个方法所做的是设置_dataSource的entry为YES或者NO。

Build and run the app. Now when the FriendsPickerViewController is launched the UITableView is be populated with the local player’s friends. The details for each friend, such as their name and profile picture, are also displayed in each cell. Here’s what it looks like:
编译并运行。到这里FriendsPickerViewController就可以显示出带有本地玩家的好友信息的UITableView了。每个好友的详细信息，比如名字和头像，也会被显示在每个cell中。如下图所示：

<a href="http://www.raywenderlich.com/?attachment_id=23242" rel="attachment wp-att-23242"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/friends_picker_view_controller_showing_friends_info.png" alt="" title="friends_picker_view_controller_showing_friends_info" width="532" height="355" class="alignnone size-full wp-image-23242" /></a>

The final thing left to do is to actually send the challenge. Replace challengeButtonPressed: in <em>FriendsPickerViewController.m</em> with the following:
最后一件要做的事就是实际发送挑战了。把<em>FriendsPickerViewController.m</em>中的challengeButtonPressed:替换为以下内容：

<pre lang="objc">
- (void)challengeButtonPressed:
                (id) sender {
    
    //1
    if(self.challengeTextField.text.
                        length > 0) {
        
        //2
        NSMutableArray *playerIds =
                    [NSMutableArray array];
        NSArray *allValues =
                    [_dataSource allValues];

        for (NSDictionary *dict in allValues) {
            if ([dict[kIsChallengedKey]
                            boolValue] == YES) {
                
                GKPlayer *player =
                    dict[kPlayerKey];
                [playerIds addObject:
                    player.playerID];
            }
        }
        if (playerIds.count > 0) {
            
            //3
            [[GameKitHelper sharedGameKitHelper]
                sendScoreChallengeToPlayers:playerIds
                withScore:_score message:
                    self.challengeTextField.text];
        }
        
        if (self.challengeButtonPressedBlock) {
            self.challengeButtonPressedBlock();
        }
    } else {
        self.challengeTextField.layer.
                borderWidth = 2;
        self.challengeTextField.layer.
                borderColor =
                    [UIColor redColor].CGColor;
    }
} 
</pre>

Here is a step-by-step explanation of the above method:
以下是上面方法的详细步骤分解：
<ol>
<li>The method first checks to see if the user has entered a message. If not, the border of the challengeTextField is turned red.</li>
<li>此方法首先检查玩家是否输入了消息。如果没有，就把challengeTextField的边框设为红色。</li>
<li>If the user has entered text, the method finds the player IDs of all the selected players and stores them in an array called playerIds.</li>
<li>如果用户输入了文本，此方法择查找所有被选中的玩家ID，并把它们保存到playerIds数组中。</li>
<li>If the user has selected players to challenge, then sendScoreChallengeToPlayers:withScore: is called from GameKitHelper with those player IDs. This will send the challenge to all the selected players.</li>
<li>如果用户选择了一个火一个以上的玩家挑战的话，则使用玩家ID作为参数调用GameKitHelper的sendScoreChallengeToPlayers:withScore:方法。此方法会发送挑战给所有已选择的玩家。</li>
</ol>
Build and run the game. Now when you press the Challenge Friends button on the FriendsPickerViewController, it will send out a score challenge. If you have two devices you can easily test this to see if it works.
编译并运行游戏。现在当你点击FriendsPickerViewController界面的Challenge Friends按钮时，它会发送一个分数挑战。如果你有两台设备，你就可以轻易地测试它们是否工作正常了。

Challenges unlocked! w00t - you can now send challenges through code!
挑战被成功解锁！你现在可以使用代码发送挑战了！

<a href="http://www.raywenderlich.com/?attachment_id=23231" rel="attachment wp-att-23231"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/10/achievement_unlocked-480x114.png" alt="" title="achievement_unlocked" width="480" height="114" class="alignnone size-medium wp-image-23231" /></a>

<h2>Where To Go From Here?</h2>
<h2>何去何从？</h2>

Here is the final project. 
这是<a href=​"http:​/​/​cdn1.raywenderlich.com/​wp-content/​uploads/​2012/​10/​MonkeyJumpFinal.zip">最终的工程​</a>​。

If you want to learn more about GameKit and all the awesome new things introduced be sure to check out our new book titled <a href="/?page_id=19968">iOS 6 by Tutorials</a>!
如果你想要学习更多有关GameKit的内容或者其他新引入的功能，请关注我们的新书<a href="/?page_id=19968">iOS 6 by Tutorials</a>！

The books has 2 full length chapters on GameKit and covers the following topics:
本书有两个完整的章节来讲述GameKit，分为如下几个主题：

<ol>
<li>Details on new classes introduced such as GKGameCenterViewController.</li>
<li>新引入的类的详细说明，比如GKGameCenterViewController。</li>
<li>Setting up achievements for the monkey jump game and unlocking them through GameKit.</li>
<li>设置monkey jump游戏成就，并在游戏中通过GameKit解锁成就。</li>
<li>Reporting achievement using GameKit.</li>
<li>使用GameKit上传成就。</li>
<li>Sending achievement challenges to friends.</li>
<li>向好友发送成就挑战。</li>
<li>Sharing score and achievements on social channels such as facebook, twitter etc.</li>
<li>通过facebook，twitter等等社交平台分享分数和成就。</li>
<li>Adding the ability to record every move the player makes and sending that data along with a challenge.</li>
<li>添加记录玩家在游戏中每次移动的信息的功能，之后将其和挑战一起发送。</li>
<li>Adding a ghost mode that show every move the challenger made while you are trying to beat a challenge.</li>
<li>添加一个幽灵猴子，当你视图战胜一个挑战时，它用来代表被挑战的玩家的每步移动。</li>
</ol>

So definitely check out <a href="/?page_id=19968">iOS 6 by Tutorials</a> as there a ton you will get to learn! In the meantime, if you have any questions or comments on this tutorial, please join the forum discussion below!
所以一定要看看<a href="/?page_id=19968">iOS 6 by Tutorials</a>，因为它里边有很多很多你想要学习的内容！同时，如果你对本教程有什么疑问或者评论，欢迎参加下方的讨论区！

<img src="http://www.raywenderlich.com/downloads/AliHafizji.jpg" class="photo left" width="100" height="100"><i>This is a blog post by iOS Tutorial Team member <a href="/?page_id=9#alihafizji">Ali Hafizji</a>, an iOS and Android developer working at <a href="http://tavisca.com/">Tavisca Solutions</a>.</i>
<img src="http://www.raywenderlich.com/downloads/AliHafizji.jpg" class="photo left" width="100" height="100"><i>本篇教程由iOS教程组成员<a href="/?page_id=9#alihafizji">Ali Hafizji</a>发表，他是一名iOS和Android开发者，目前在<a href="http://tavisca.com/">Tavisca Solutions</a>工作。</i>